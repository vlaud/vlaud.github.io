---
layout: post
title: "C++ 정규 표현식 <regex> 완전 정복"
date: 2025-08-20
categories: [STL]
tags: [cplusplus, cplusplus11, regex, String]
---

## 개념
C++11 표준부터 `<regex>` 헤더를 통해 정규 표현식(Regular Expression) 기능이 공식적으로 도입되었다. 이를 통해 개발자들은 외부 라이브러리 없이도 강력한 문자열 패턴 매칭, 검색, 치환 기능을 사용할 수 있게 되었다.

- **특징 1:** 문자열의 유효성 검사(validation), 특정 패턴 검색(searching), 텍스트 치환(replacement) 등 복잡한 문자열 처리 작업을 간결한 코드로 구현할 수 있다.
- **특징 2:** `std::regex_match`, `std::regex_search`, `std::regex_replace` 등 직관적인 이름의 함수를 제공하여 용도에 맞게 사용하기 편리하다.
- **대표적인 예:** 이메일 주소 형식 검증, 로그 파일에서 특정 데이터 추출, HTML 태그 제거, 코드 포맷팅 등 다양한 응용이 가능하다.

## 핵심 구성 요소
C++ `<regex>` 라이브러리는 여러 클래스와 함수로 구성되어 있다. 그중 핵심은 다음과 같다.

1.  **`std::regex`**: 정규 표현식 패턴 자체를 저장하고 컴파일하는 클래스.
2.  **`std::smatch`**: 정규 표현식 검색 결과를 담는 컨테이너. `std::string`에 대한 결과를 담으며, 캡처된 그룹(captured group)에 대한 접근을 제공한다. (`const char*`의 경우 `cmatch`)
3.  **`std::regex_match()`**: **전체 문자열**이 패턴과 완전히 일치하는지 검사한다.
4.  **`std::regex_search()`**: 문자열 내에서 패턴과 일치하는 **부분 문자열**이 있는지 검색한다.
5.  **`std::regex_replace()`**: 패턴과 일치하는 부분을 다른 문자열로 치환한다.
6.  **`std::sregex_iterator`**: 문자열 내의 모든 일치 항목을 순회할 수 있는 반복자.

## 주요 사용법과 예시

### 1. 전체 문자열 일치 (`std::regex_match`)
문자열 전체가 주어진 형식과 정확히 일치하는지 확인할 때 사용한다. 사용자 입력 값의 유효성을 검사하는 데 매우 유용하다.

```cpp
#include <iostream>
#include <string>
#include <regex>

int main() {
    // YYYY-MM-DD 형식의 날짜 패턴
    std::regex date_pattern(R"(^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])$)");

    std::string date1 = "2025-08-20";
    std::string date2 = "2025-8-20"; // MM, DD가 두 자리가 아님

    if (std::regex_match(date1, date_pattern)) {
        std::cout << date1 << ": 유효한 날짜 형식입니다." << std::endl;
    }

    if (!std::regex_match(date2, date_pattern)) {
        std::cout << date2 << ": 유효하지 않은 날짜 형식입니다." << std::endl;
    }
    return 0;
}
```

### 2. 부분 문자열 검색과 캡처 그룹 활용 (`std::regex_search`, `std::smatch`)
문자열의 일부에서 정보를 추출할 때 사용한다. `smatch` 객체를 이용하면 캡처 그룹 `()`으로 잡은 특정 부분만 따로 얻을 수 있다.

`smatch` 객체는 배열처럼 접근할 수 있다.
- `match[0]`: 패턴과 일치한 전체 문자열
- `match[1]`: 첫 번째 `()` 그룹이 캡처한 문자열
- `match[2]`: 두 번째 `()` 그룹이 캡처한 문자열

```cpp
#include <iostream>
#include <string>
#include <regex>

int main() {
    std::string log = "ERROR: [main.cpp:101] - File not found";
    // 로그에서 파일 이름과 라인 번호를 추출하는 패턴
    std::regex log_pattern(R"(\[([a-zA-Z._]+):(\d+)\])");
    std::smatch match;

    if (std::regex_search(log, match, log_pattern)) {
        std::cout << "전체 매치: " << match[0].str() << std::endl;
        std::cout << "파일 이름: " << match[1].str() << std::endl;
        std::cout << "라인 번호: " << match[2].str() << std::endl;
    }
    return 0;
}
```

### 3. 모든 일치 항목 순회 (`std::sregex_iterator`)
문자열에 포함된 모든 패턴 일치 항목을 찾고 싶을 때 반복자를 사용하면 코드가 매우 간결해진다.

```cpp
#include <iostream>
#include <string>
#include <regex>

int main() {
    std::string text = "Apple price is $150, and Banana price is $80.";
    std::regex price_pattern(R"(\$(\d+))");

    // sregex_iterator를 사용하여 모든 가격 정보를 찾는다.
    auto words_begin = std::sregex_iterator(text.begin(), text.end(), price_pattern);
    auto words_end = std::sregex_iterator();

    std::cout << "찾은 가격 목록:" << std::endl;
    for (std::sregex_iterator i = words_begin; i != words_end; ++i) {
        std::smatch match = *i;
        // 첫 번째 캡처 그룹($ 제외)의 값을 출력한다.
        std::cout << "- " << match[1].str() << std::endl;
    }
    return 0;
}
```

### 4. 문자열 치환 (`std::regex_replace`)
패턴에 해당하는 부분을 다른 문자열로 바꿀 때 사용한다. 민감한 정보를 마스킹하는 데 유용하다.

```cpp
#include <iostream>
#include <string>
#include <regex>

int main() {
    std::string text = "Email: user@example.com, Phone: 010-1234-5678";
    std::regex email_pattern(R"([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})");

    // 이메일 주소를 "[REDACTED]"로 치환한다.
    std::string replaced_text = std::regex_replace(text, email_pattern, "[REDACTED]");

    std::cout << "원본: " << text << std::endl;
    std::cout << "수정: " << replaced_text << std::endl;
    return 0;
}
```

## 주의할 점
### Raw String Literal 사용
C++ 문자열 리터럴에서 백슬래시 `\`는 이스케이프 문자로 취급된다. 따라서 정규 표현식의 `\d`를 일반 문자열로 쓰려면 백슬래시를 두 번 써줘야 한다.

```cpp
std::regex re("\\d+"); // "\\d+"는 실제로 "\d+"로 해석됨
```

하지만 C++11 이상의 Raw String Literal(원시 문자열 리터럴)을 사용하면, 백슬래시나 따옴표 같은 문자들을 이스케이프할 필요 없이 있는 그대로 쓸 수 있어 훨씬 간결하다.

```cpp
std::regex re(R"(\d+)"); // Raw String Literal 사용 → \d+ 그대로
```