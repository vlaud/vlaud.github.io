---
layout: post
title: "마나커 알고리즘 (Manacher's Algorithm) - 개념과 예시"
date: 2025-08-20
categories: [Algorithm, Data Structure]
tags: [Manacher, Palindrome, String, Algorithm]
---

## 개념
마나커(Manacher) 알고리즘은 특정 문자열에서 가장 긴 팰린드롬(palindrome, 회문) 부분 문자열을 선형 시간, 즉 O(n)에 찾아내는 매우 효율적인 알고리즘이다.

- **특징 1:** 일반적인 O(n^2) 풀이법(모든 부분 문자열을 확인하며 팰린드롬 여부를 검사하는 방식)을 획기적으로 개선한 알고리즘이다.
- **특징 2:** 알고리즘의 핵심은 **'이미 계산된 팰린드롬 정보를 재사용'**하여 불필요한 문자 비교를 최소화하는 데 있다.
- **대표적인 예:** 문자열 검색, 데이터 압축, 바이오인포매틱스 등 다양한 분야에서 활용될 수 있다.

## 주요 원리
마나커 알고리즘은 두 가지 핵심적인 아이디어를 통해 선형 시간 복잡도를 달성한다.

### 1. 전처리 (Preprocessing)
기존의 팰린드롬 판별 알고리즘은 "aba"처럼 길이가 홀수인 경우와 "abba"처럼 길이가 짝수인 경우를 모두 고려해야 해서 구현이 복잡해진다. 마나커 알고리즘은 문자열을 간단히 변형하여 이 문제를 해결한다.

문자열의 각 문자 사이와 양 끝에 `#`과 같은 특수 문자를 삽입한다.

- `aba` → `#a#b#a#`
- `abba` → `#a#b#b#a#`

이렇게 변형하면, 원래 문자열에서 길이가 홀수이든 짝수이든 상관없이 **모든 팰린드롬이 변형된 문자열에서는 길이가 홀수인 팰린드롬이 된다.** 이로써 모든 팰린드롬을 동일한 방식으로 다룰 수 있다.

### 2. 팰린드롬 반지름 배열 (P 배열)과 정보 재사용
알고리즘의 핵심이다. `P`라는 배열을 만들어, 변형된 문자열의 각 인덱스 `i`를 중심으로 최대로 확장할 수 있는 팰린드롬의 **반지름**을 저장한다.

예를 들어, `S' = #a#b#a#`의 `P` 배열은 다음과 같다.

| `S'` | # | a | # | b | # | a | # |
| :-- | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| **i** | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| **P[i]**| 0 | 1 | 0 | 3 | 0 | 1 | 0 |

- `P[3] = 3`은 인덱스 3을 중심으로 하는 팰린드롬이 `#a#b#a#`이고, 그 반지름이 3이라는 의미다. (중심 `b`로부터 `#`까지의 거리)
- `P` 배열의 값 `p`는 변형 전 원래 문자열에서의 팰린드롬 길이와 같다.

알고리즘은 `i`를 0부터 `n-1`까지 순회하며 `P[i]`를 계산한다. 이때, 이전에 계산된 `P` 값을 재사용하여 계산 속도를 높인다. `c`(가장 오른쪽으로 뻗어있는 팰린드롬의 중심), `r`(해당 팰린드롬의 오른쪽 경계) 변수를 유지하며 다음 규칙에 따라 `P[i]`를 효율적으로 계산한다.

- 현재 인덱스 `i`가 이전에 찾은 팰린드롬의 경계 `r` 내에 있다면 (`i < r`), `i`의 대칭점인 `i_mirror = 2*c - i`의 `P` 값을 활용해 `P[i]`의 초기값을 설정할 수 있다.
- 이를 통해, `P[i]`를 처음부터 계산하는 것이 아니라, 일정 값 이상에서 시작할 수 있게 되어 시간 복잡도를 줄인다.

## 알고리즘 과정
1.  **문자열 전처리:** 입력 문자열 `s`를 `#`를 삽입한 `s'`로 변환한다.
2.  **`P` 배열, `c`, `r` 초기화:** `P` 배열을 0으로, `c`와 `r`도 0으로 초기화한다.
3.  **순회 및 `P[i]` 계산:** `i`를 0부터 `n-1`까지 순회한다.
    - `i`의 대칭점 `i_mirror = 2*c - i`를 구한다.
    - 만약 `i < r` 이라면, `P[i] = min(r - i, P[i_mirror])`로 초기화한다. `r-i`는 `r` 경계까지 남은 거리이고, `P[i_mirror]`는 대칭점의 팰린드롬 반지름이다. 둘 중 작은 값을 택해야 경계를 벗어나지 않는다.
    - `i`를 중심으로 좌우 문자가 같을 동안 `P[i]`를 1씩 증가시키며 팰린드롬을 확장한다.
    - 만약 `i`에서 확장한 팰린드롬의 오른쪽 경계(`i + P[i]`)가 기존 `r`보다 크다면, `c`를 `i`로, `r`을 `i + P[i]`로 갱신한다.
4.  **최대값 찾기:** `P` 배열에서 가장 큰 값을 찾는다. 이 값이 가장 긴 팰린드롬의 반지름이다.

### C++ 코드 예시

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

std::string longestPalindrome(std::string s) {
    if (s.empty()) return "";

    // 1. 문자열 전처리
    std::string t = "#";
    for (char c : s) {
        t += c;
        t += '#';
    }

    int n = t.length();
    std::vector<int> p(n, 0); // 각 위치를 중심으로 하는 팰린드롬의 반지름을 저장

    int c = 0, r = 0; // 현재까지 발견된 팰린드롬의 중심(c)과 오른쪽 경계(r)

    for (int i = 0; i < n; ++i) {
        // 2. i의 대칭점 i_mirror를 이용해 p[i]의 초기값을 구한다.
        int i_mirror = 2 * c - i;
        if (i < r) {
            p[i] = std::min(r - i, p[i_mirror]);
        }

        // 3. i를 중심으로 팰린드롬 확장
        // 경계를 벗어나지 않고, 양쪽 문자가 같은 동안 반지름을 1씩 늘린다.
        int a = i + (1 + p[i]);
        int b = i - (1 + p[i]);
        while (a < n && b >= 0 && t[a] == t[b]) {
            p[i]++;
            a++;
            b--;
        }

        // 4. c와 r을 업데이트
        // 현재 i에서 찾은 팰린드롬이 기존의 r보다 더 오른쪽에 도달하면 c와 r을 갱신한다.
        if (i + p[i] > r) {
            c = i;
            r = i + p[i];
        }
    }

    // 5. 가장 긴 팰린드롬을 찾아서 반환
    int max_len = 0;
    int center_index = 0;
    for (int i = 0; i < n; ++i) {
        if (p[i] > max_len) {
            max_len = p[i];
            center_index = i;
        }
    }

    // 전처리된 문자열 인덱스에서 원래 문자열 인덱스로 변환하여 반환
    int start = (center_index - max_len) / 2;
    return s.substr(start, max_len);
}

int main() {
    std::string s1 = "babad";
    std::cout << "'" << s1 << "'의 가장 긴 팰린드롬: " << longestPalindrome(s1) << std::endl;

    std::string s2 = "cbbd";
    std::cout << "'" << s2 << "'의 가장 긴 팰린드롬: " << longestPalindrome(s2) << std::endl;
    return 0;
}
```

## 복잡도 분석
- **시간 복잡도: O(n)**
  - `for` 루프는 `n`번 반복된다. 내부의 `while` 루프 때문에 O(n^2)처럼 보일 수 있지만, `r`은 절대 감소하지 않고 오른쪽으로만 증가한다. `while` 루프가 한 번 실행될 때마다 `r`도 한 칸씩 움직이므로, `while` 루프의 총 실행 횟수는 `n`을 넘지 않는다. 따라서 전체 시간 복잡도는 O(n)이다.
- **공간 복잡도: O(n)**
  - 전처리된 문자열 `t`와 반지름 배열 `p`를 저장하기 위해 입력 문자열 길이에 비례하는 O(n)의 추가 공간이 필요하다.

## 마치며
마나커 알고리즘은 팰린드롬 관련 문제에 있어 거의 최종 병기와 같은 해결책이다. 전처리 트릭과 이전에 계산한 정보를 재활용하는 아이디어를 통해 복잡도를 O(n)까지 낮춘 점이 인상적이다. 알고리즘의 핵심 원리, 특히 `c`와 `r`을 이용해 `P` 배열을 효율적으로 채워나가는 과정을 이해하는 것이 중요하다.

---

*작성일: 2025.08.20*<br/>
*작성자: Cho Donghyun*
