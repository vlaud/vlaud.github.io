---
layout: post
title: "C++ 문자열 연산: const char*와 char의 덧셈 함정"
date: 2025-10-01
categories: [STL]
tags: [cplusplus, String, Bug, Error, Pointer]
---

## 문제의 코드
C++로 코딩할 때, 문자열 `s`의 모든 문자 앞에 `#`을 붙여 새로운 문자열 `t`를 만들고 싶을 때가 있다. 많은 개발자들이 다음과 같은 코드를 직관적으로 작성하곤 한다.

```cpp
std::string s = "Hello";
std::string t = "";
for (char c : s) {
    t += "#" + c; // 컴파일 에러 또는 런타임 에러 발생
}
```

이 코드는 매우 그럴듯해 보이지만, 실제로는 컴파일 에러를 일으키거나 의도치 않은 동작으로 이어진다. 이 포스트에서는 왜 이런 문제가 발생하는지와 올바른 해결책을 설명한다.

## 주요 원인: 포인터 연산
문제의 핵심은 `"#"`의 자료형과 `+` 연산자의 동작 방식에 있다.

1.  **`"#"`은 `std::string`이 아니다**
    - C++에서 큰따옴표로 묶인 문자열 리터럴(literal)은 `std::string` 객체가 아니라 `const char*` 타입, 즉 C-스타일 문자열이다. 정확히는 `const char[2]` 타입의 배열이고, 이는 표현식에서 `const char*` 포인터로 변환(decay)된다.

2.  **`const char*`와 `char`의 덧셈**
    - `+` 연산은 한쪽이 `std::string` 객체일 때 우리가 아는 '문자열 연결'로 동작한다. 하지만 `const char*`와 `char`의 덧셈은 포인터 연산으로 해석된다.
    - `char` 타입인 `c`는 정수형으로 승격(promotion)되어 자신의 아스키(ASCII) 코드 값으로 변환된다.
    - 결국 `"#"` + `c`는 `"#"` 문자열 리터럴이 저장된 메모리 주소에 `c`의 아스키 코드 값을 더하는 연산이 된다.

예를 들어, `c`가 'H'(아스키 코드 72)라면, 코드는 `"#"`의 시작 주소에서 72바이트 떨어진 곳을 가리키는 포인터를 만들려고 시도한다. 이 주소는 대부분 유효하지 않은 메모리 공간이므로, 프로그램은 비정상적으로 종료되거나 예측할 수 없는 값을 출력하게 된다.

## 해결 방법
이 문제를 해결하는 방법은 간단하다. `+` 연산자의 한쪽 피연산자를 `std::string` 객체로 만들어주면 된다.

### 해결책 1: `std::string`으로 변환 후 연산
`"#"`을 `std::string` 객체로 명시적으로 변환하면, `std::string`의 `operator+`가 호출되어 올바르게 문자열 연결을 수행한다.

```cpp
// 해결 코드 1
std::string s = "Hello";
std::string t = "";
for (char c : s) {
    // "#"을 std::string으로 변환하여 문자열 연결을 유도한다.
    t += std::string("#") + c;
}
// t의 결과: "#H#e#l#l#o"
```

### 해결책 2: 각각 따로 추가하기
더 효율적인 방법은 임시 `std::string` 객체를 만들지 않고, 각 부분을 `t`에 순서대로 추가하는 것이다.

```cpp
// 해결 코드 2
std::string s = "Hello";
std::string t = "";
for (char c : s) {
    // '#' 문자를 먼저 추가하고,
    t += '#'; 
    // 그 다음에 c 문자를 추가한다.
    t += c;
}
// t의 결과: "#H#e#l#l#o"
```
이 방법은 불필요한 임시 객체 생성을 피하므로 성능상 이점이 있다. `t.push_back('#')`와 `t.push_back(c)`를 사용해도 동일한 결과를 얻을 수 있다.

## 마치며
C++에서 문자열을 다룰 때는 `const char*`와 `std::string`의 차이점을 명확히 이해하는 것이 중요하다. 특히 `+` 연산자를 사용할 때는 최소 한쪽이 `std::string` 객체인지 확인해야 의도치 않은 포인터 연산을 피할 수 있다. 간단해 보이는 코드라도 내부 동작 원리를 이해하지 못하면 디버깅하기 어려운 문제에 직면할 수 있다는 점을 기억하자.

---

*작성일: 2025.10.01*<br/>
*작성자: Cho Donghyun*
