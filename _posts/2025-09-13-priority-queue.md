---
layout: post
title: 우선 순위 큐 (Priority Queue) - 개념과 예시
date: 2025-09-13T07:17:08.693Z
categories:
    - Data Structure
    - Algorithm
tags:
    - Priority Queue
    - Heap
    - 자료구조
description: 우선 순위 큐에 대해 설명하고자 한다.
---

## 개념
우선 순위 큐(Priority Queue)는 각 요소가 '우선순위'를 가지고 있는 특별한 큐다. 일반적인 큐가 먼저 들어온 데이터가 먼저 나가는 FIFO(First-In, First-Out) 방식인 것과 달리, 우선 순위 큐는 우선순위가 가장 높은 요소가 먼저 처리된다.

- **특징 1:** 높은 우선순위를 가진 요소가 낮은 우선순위를 가진 요소보다 먼저 나온다. 우선순위가 같다면 큐에 추가된 순서에 따라 처리될 수 있지만, 이는 구현에 따라 달라질 수 있다.
- **특징 2:** 주로 힙(Heap) 자료구조를 이용해 구현되며, 이 덕분에 요소를 추가하거나 삭제(가장 높은 우선순위의 요소를 꺼내는 작업)할 때 O(log n)의 시간 복잡도를 가진다.
- **대표적인 예:** 다익스트라(Dijkstra) 알고리즘이나 A* 탐색 알고리즘에서 다음으로 방문할 노드를 결정할 때 사용된다.

## 주요 연산 및 원리
우선 순위 큐는 보통 힙(Heap)으로 구현된다. 힙은 완전 이진 트리 형태로, 각 노드의 값이 자식 노드의 값보다 항상 크거나 같은(Max Heap) 또는 작거나 같은(Min Heap) 속성을 만족한다.

1.  **`push(element)`**
    - 새로운 요소를 힙의 가장 마지막 위치에 추가한다.
    - 부모 노드와 우선순위를 비교하며, 새로운 요소의 우선순위가 더 높다면 부모와 자리를 바꾼다. 이 과정을 힙의 속성이 만족될 때까지 반복한다. (이를 'heapify-up' 또는 'percolate-up'이라 한다.)
2.  **`pop()`**
    - 우선순위가 가장 높은 루트(root) 노드를 제거한다.
    - 힙의 가장 마지막 요소를 루트 위치로 가져온다.
    - 자식 노드와 우선순위를 비교하며, 현재 노드의 우선순위가 더 낮다면 자식과 자리를 바꾼다. 이 과정을 힙의 속성이 만족될 때까지 반복한다. (이를 'heapify-down' 또는 'percolate-down'이라 한다.)
3.  **`top()`**
    - 힙의 루트 노드를 반환한다. 이 연산은 힙의 구조를 변경하지 않으며, O(1)의 시간 복잡도를 가진다.

## 예시: C++ `std::priority_queue`
C++ 표준 라이브러리는 `std::priority_queue`를 제공하여 우선 순위 큐를 쉽게 사용할 수 있다. 기본적으로 Max Heap으로 동작한다.

### Max Heap (기본)
가장 큰 값이 가장 높은 우선순위를 가진다.

```cpp
#include <iostream>
#include <queue>
#include <vector>

int main() {
    // 기본 우선 순위 큐 (Max Heap)
    std::priority_queue<int> pq;

    pq.push(30);
    pq.push(100);
    pq.push(20);
    pq.push(50);

    std::cout << "Max Heap에서 원소 꺼내기:" << std::endl;
    while (!pq.empty()) {
        // top()은 가장 큰 원소를 반환
        std::cout << pq.top() << " ";
        pq.pop(); // 가장 큰 원소 제거
    }
    std::cout << std::endl; // 출력: 100 50 30 20

    return 0;
}
```

### Min Heap
가장 작은 값이 가장 높은 우선순위를 가지도록 만들려면 `std::greater`를 사용해야 한다.

```cpp
#include <iostream>
#include <queue>
#include <vector>
#include <functional>

int main() {
    // Min Heap으로 동작하는 우선 순위 큐
    std::priority_queue<int, std::vector<int>, std::greater<int>> min_pq;

    min_pq.push(30);
    min_pq.push(100);
    min_pq.push(20);
    min_pq.push(50);

    std::cout << "Min Heap에서 원소 꺼내기:" << std::endl;
    while (!min_pq.empty()) {
        // top()은 가장 작은 원소를 반환
        std::cout << min_pq.top() << " ";
        min_pq.pop(); // 가장 작은 원소 제거
    }
    std::cout << std::endl; // 출력: 20 30 50 100

    return 0;
}
```

## 실전 예시: 다익스트라 알고리즘
다익스트라 알고리즘은 한 정점에서 다른 모든 정점까지의 최단 경로를 찾는 알고리즘이다. 이때, 다음으로 탐색할 정점을 선택하는 기준으로 '시작점으로부터 가장 거리가 짧은 정점'을 고르는데, 이 과정에서 우선 순위 큐가 매우 효율적으로 사용된다.

- **문제 상황:** 그래프에서 시작 정점이 주어졌을 때, 다른 모든 정점까지의 최단 거리를 구해야 한다.
- **우선 순위 큐 적용:**
    1. (거리, 정점) 쌍을 우선 순위 큐에 저장한다. 이때 거리가 짧을수록 우선순위가 높도록 Min Heap을 사용한다.
    2. 시작 정점의 거리는 0으로 하여 큐에 넣는다.
    3. 큐가 빌 때까지 다음을 반복한다:
        - 큐에서 우선순위가 가장 높은(거리가 가장 짧은) 정점을 꺼낸다.
        - 해당 정점을 통해 갈 수 있는 다른 정점들의 거리를 계산하고, 기존 거리보다 짧아진다면 갱신한 뒤 큐에 넣는다.

이 방식을 통해 매번 모든 정점을 확인할 필요 없이, 현재 가장 가능성 있는(거리가 짧은) 정점을 O(log V) 시간만에 효율적으로 선택할 수 있다. (V는 정점의 개수)

## 마치며
우선 순위 큐는 단순히 데이터를 쌓아두는 것을 넘어, '중요도'에 따라 작업을 처리해야 할 때 빛을 발하는 자료구조다. 힙을 통해 효율적으로 구현되며, 최단 경로 탐색, 작업 스케줄링 등 다양한 알고리즘과 시스템에서 핵심적인 역할을 수행한다. 따라서 그 원리를 잘 이해하고 적재적소에 활용하는 것이 중요하다.

---

*작성일: 2025.09.13*<br/>
*작성자: Cho Donghyun*
